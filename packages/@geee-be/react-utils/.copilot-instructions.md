# @geee-be/react-utils - Copilot Instructions

## Package Overview
A collection of reusable React hooks and utility functions designed to enhance React applications with common functionality patterns. This package provides lightweight, well-tested utilities that work seamlessly with modern React patterns, SSR frameworks, and TypeScript. Focuses on performance, type safety, and developer experience.

## Package Structure
```
src/
├── helpers/                    # Utility functions and components
│   ├── index.ts               # Helper exports
│   ├── client-only.tsx        # Client-side only rendering wrapper
│   ├── monitor.tsx            # Performance monitoring utilities
│   ├── ripple.ts             # Material Design ripple effect
│   └── sub-component.tsx      # Component composition helpers
├── hooks/                     # Custom React hooks
│   ├── index.ts               # Hook exports
│   ├── state.util.ts          # State management utilities
│   ├── use-broadcast-channel.ts # Cross-tab communication
│   ├── use-history-state.ts   # Browser history state management
│   ├── use-is-client.ts       # Client-side detection
│   ├── use-is-mobile.ts       # Mobile device detection
│   ├── use-local-state.ts     # Enhanced local state management
│   └── use-local-state.stories.tsx # Storybook examples
└── index.ts                   # Package main export
```

## Package Structure
```
src/
├── helpers/          # Utility functions and components
│   ├── client-only.tsx    # Client-side only rendering wrapper
│   ├── monitor.tsx        # Performance monitoring utilities
│   ├── ripple.ts         # Material Design ripple effect
│   └── sub-component.tsx  # Component composition helpers
└── hooks/            # Custom React hooks
    ├── state.util.ts           # State management utilities
    ├── use-broadcast-channel.ts # Cross-tab communication
    ├── use-history-state.ts    # Browser history state management
    ├── use-is-client.ts        # Client-side detection
    ├── use-is-mobile.ts        # Mobile device detection
    └── use-local-state.ts      # Enhanced local state management
```

## Key Dependencies
- **@uidotdev/usehooks**: Additional utility hooks
- **React 18+**: Modern React features and patterns

## Hook Implementation Patterns

### State Management Hooks
- `useLocalState`: Enhanced useState with localStorage persistence and cross-tab sync
- `useHistoryState`: State management with browser history integration
- State utilities for common patterns and transformations

### Environment Detection Hooks
- `useIsClient`: Detect client-side rendering vs SSR (prevents hydration mismatches)
- `useIsMobile`: Responsive mobile device detection with customizable breakpoints

### Communication Hooks
- `useBroadcastChannel`: Cross-tab/window communication using Broadcast Channel API

### Performance Considerations
- All hooks use proper dependency arrays and cleanup
- Memoization implemented where beneficial for performance
- Automatic event listener cleanup on component unmount
- SSR-safe initialization patterns to prevent hydration issues

## Helper Functions

### Component Utilities
- `ClientOnly`: Wrapper for client-side only rendering
- `SubComponent`: Utilities for component composition patterns
- `Monitor`: Performance monitoring and debugging tools

### Effects and Interactions
- `ripple`: Material Design ripple effect implementation

## Development Patterns

### Hook Implementation
- Follow React hooks rules and conventions
- Use TypeScript for type safety
- Implement proper cleanup in useEffect
- Support SSR/client-side rendering differences
- Provide sensible default values

### Utility Functions
- Pure functions where possible
- Proper error handling
- TypeScript strict mode compliance
- Minimal external dependencies

## TypeScript Support
- Full TypeScript definitions for all exports
- Generic types for flexible hook APIs
- Proper inference for hook return types
- Strict type checking enabled

## Usage Examples

### Enhanced State Management
```typescript
import { useLocalState, useHistoryState } from '@geee-be/react-utils';

// Persistent state with localStorage
function UserPreferences() {
  const [settings, setSettings] = useLocalState('user-settings', {
    theme: 'light',
    language: 'en',
    notifications: true
  });

  const toggleTheme = () => {
    setSettings(prev => ({
      ...prev,
      theme: prev.theme === 'light' ? 'dark' : 'light'
    }));
  };

  return <button onClick={toggleTheme}>Theme: {settings.theme}</button>;
}

// Browser history integration
function SearchPage() {
  const [query, setQuery] = useHistoryState('search', '');
  const [filters, setFilters] = useHistoryState('filters', {});

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      {/* Filters persist in browser history */}
    </div>
  );
}
```

### SSR-Safe Environment Detection
```typescript
import { useIsClient, useIsMobile } from '@geee-be/react-utils';

function ResponsiveComponent() {
  const isClient = useIsClient();
  const isMobile = useIsMobile(768); // Custom breakpoint

  // Prevent hydration mismatch
  if (!isClient) {
    return <div>Loading...</div>;
  }

  return (
    <div className={isMobile ? 'mobile-layout' : 'desktop-layout'}>
      <h1>Welcome</h1>
      {isMobile ? <MobileNavigation /> : <DesktopNavigation />}
    </div>
  );
}
```

### Cross-Tab Communication
```typescript
import { useBroadcastChannel } from '@geee-be/react-utils';

function MultiTabSync() {
  const [message, postMessage] = useBroadcastChannel('app-sync');

  useEffect(() => {
    if (message) {
      console.log('Received from another tab:', message);
      // Handle cross-tab state synchronization
    }
  }, [message]);

  const notifyOtherTabs = () => {
    postMessage({
      type: 'USER_LOGIN',
      user: { id: 1, name: 'John' },
      timestamp: Date.now()
    });
  };

  return <button onClick={notifyOtherTabs}>Login & Sync</button>;
}
```

### Utility Components
```typescript
import { ClientOnly, ripple } from '@geee-be/react-utils';

// Client-only rendering
function App() {
  return (
    <div>
      <h1>Server + Client Rendered</h1>
      <ClientOnly>
        <ExpensiveClientComponent />
        <BrowserAPIComponent />
      </ClientOnly>
    </div>
  );
}

// Material Design ripple effect
function RippleButton() {
  const handleClick = (event) => {
    ripple(event.currentTarget, {
      duration: 600,
      color: 'rgba(59, 130, 246, 0.3)'
    });
  };

  return (
    <button
      onClick={handleClick}
      className="relative overflow-hidden bg-blue-500 text-white px-4 py-2 rounded"
    >
      Click for Ripple
    </button>
  );
}
```

## Build Configuration
- **TypeScript Compilation**: Direct tsc build to `dist/`
- **Type Exports**: Source types exported directly (`src/index.ts`)
- **Development Mode**: Watch mode with `tsc --watch`
- **ES Modules**: Modern ESM output format

## Testing & Development
- **Storybook Integration**: Stories for demonstrating hook usage
- **Type Safety**: Strict TypeScript configuration
- **Linting**: Biome for code quality
- **Development Server**: Watch mode for rapid iteration

## Best Practices

### Hook Development Guidelines
- Keep hooks focused on single responsibilities
- Follow React hooks rules and conventions
- Use TypeScript for comprehensive type safety
- Implement proper cleanup in useEffect hooks
- Handle edge cases (SSR, cleanup, errors gracefully)
- Provide sensible default values for all parameters
- Consider performance implications and optimize re-renders
- Support both development and production environments

### API Design Principles
- Provide TypeScript definitions for all public APIs
- Use proper dependency arrays in useEffect
- Implement consistent return patterns across similar hooks
- Support generic types for flexible, reusable APIs
- Follow React's built-in hook naming conventions
- Document complex hook behaviors with JSDoc comments

### Performance Optimization
- Use useCallback and useMemo appropriately
- Implement proper event listener cleanup
- Avoid unnecessary re-renders through careful state management
- Use refs for values that don't trigger re-renders
- Implement debouncing for expensive operations
- Consider memory usage in long-running applications

### Error Handling
- Provide graceful fallbacks for failed operations
- Handle browser API unavailability
- Use try-catch blocks for potentially failing operations
- Log errors appropriately for debugging
- Provide meaningful error messages for developers
- Support error boundaries where applicable

### Testing Strategies
- Test hooks in isolation using React Testing Library
- Verify SSR compatibility with server-side rendering tests
- Test browser API integration with appropriate mocks
- Validate TypeScript types compile correctly
- Test edge cases and error conditions
- Ensure cleanup functions work properly

## Framework-Specific Usage

### Next.js Integration
```typescript
// App Router (app directory)
import { useLocalState, useIsClient } from '@geee-be/react-utils';

export default function ClientComponent() {
  const isClient = useIsClient();
  const [data, setData] = useLocalState('app-data', null);

  if (!isClient) return <div>Loading...</div>;
  return <div>{data}</div>;
}

// Pages Router
import { useIsMobile } from '@geee-be/react-utils';

export default function Page() {
  const isMobile = useIsMobile();
  return <div>{isMobile ? 'Mobile' : 'Desktop'}</div>;
}
```

### Performance Monitoring
```typescript
import { Monitor } from '@geee-be/react-utils';

// Use Monitor utilities for performance tracking
function App() {
  useEffect(() => {
    Monitor.trackRender('App');
    return () => Monitor.trackUnmount('App');
  }, []);

  return <div>App Content</div>;
}
```

## SSR Considerations

### Hydration Safety Patterns
All hooks are designed to work with server-side rendering frameworks without hydration mismatches:

```typescript
// Safe pattern for SSR
function ThemeProvider({ children }) {
  const [theme, setTheme] = useLocalState('theme', 'light');
  const isClient = useIsClient();

  // Use fallback during SSR to prevent hydration mismatch
  const currentTheme = isClient ? theme : 'light';

  return (
    <div data-theme={currentTheme} className={currentTheme}>
      {children}
    </div>
  );
}

// Safe mobile detection
function ResponsiveLayout() {
  const isClient = useIsClient();
  const isMobile = useIsMobile();

  // Always render the same structure on server
  if (!isClient) {
    return <div className="responsive-container">Loading...</div>;
  }

  return (
    <div className="responsive-container">
      {isMobile ? <MobileLayout /> : <DesktopLayout />}
    </div>
  );
}
```

### Framework Integration
- **Next.js**: Full compatibility with App Router and Pages Router
- **Remix**: Works with Remix's SSR patterns and hydration
- **Gatsby**: Compatible with static site generation
- **Vite SSR**: Supports Vite's SSR implementation
- **Client-only apps**: Works perfectly in SPA environments

### Browser API Safety
- Hooks gracefully handle browser API availability
- Proper feature detection prevents runtime errors
- Fallback behavior for server environments
- Progressive enhancement patterns supported
